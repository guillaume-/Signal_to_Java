(*this module is for the sequential code generation*)
(*now, we do the optimization before code generation*)
(*#include<> for system calls, #include"" for user calls*)
(*we use the similar structure of the generated code of Polychrony*)

open Codehierarchy
open ReducenfAST
open KsignalAST
open Optimization

(*print pre-definition*)
let pre_def filename =
	"\n" ^
	"/*" ^ "\n" ^
		"Sequential c code generated by miniSIGNAL CAML tool v1.00" ^ "\n" ^
		"*/" ^ "\n" ^
	"#include \"" ^ filename ^ "_types.h\"" ^ "\n" ^
  "#include \"" ^ filename ^ "_externals.h\"" ^ "\n" ^
  "#include \"" ^ filename ^ "_body.h\""

let produce_types_file filename=
	"\n" ^
	"/*" ^ "\n" ^
		"Sequential c code generated by miniSIGNAL CAML tool v1.00" ^ "\n" ^
		"*/" ^ "\n" ^
  "#ifndef " ^ "_" ^ filename ^ "_types" ^ "\n" ^
  "#define " ^ "_" ^ filename ^ "_types" ^ "\n" ^
  "#include <stdio.h>" ^ "\n" ^
  "#include <stdlib.h>" ^ "\n" ^
  "#include <math.h>" ^ "\n" ^
  "#include \"ansi.h\"" ^ "\n" ^
  "#include \"pK_GenCodeC_Predef.h\"" ^ "\n" ^
  "#endif" 

let produce_externals_file filename=
		"\n" ^
	"/*" ^ "\n" ^
		"Sequential c code generated by miniSIGNAL CAML tool v1.00" ^ "\n" ^
		"*/" ^ "\n" ^
	"#include \"" ^ filename ^ "_externalsProc.h\""
	
let produce_body_file =
		"\n" ^
	"/*" ^ "\n" ^
		"Sequential c code generated by miniSIGNAL CAML tool v1.00" ^ "\n" ^
		"*/" ^ "\n" ^
		"EXTERN logical initialize();" ^ "\n" ^
    "static void step_initialize();" ^ "\n" ^
    "EXTERN logical step_finalize();" ^ "\n" ^
    "EXTERN logical step();" 


let produce_ext_proc_file pl=
	 List.map(
   function 
	 SProc(n,is,os,eqns,ws) -> 
			"\n" ^
	"/*" ^ "\n" ^
		"Sequential c code generated by miniSIGNAL CAML tool v1.00" ^ "\n" ^
		"*/" ^ "\n" ^
		(String.concat ";\n" (List.map (fun i->
			(match i with (st, sv) ->
							if sty2str st="integer" then
									  "EXTERN logical r_" ^ sv ^ "(int *" ^ sv ^ ")"
							else if sty2str st="boolean" || sty2str st="event" then
			             "EXTERN logical r_" ^ sv ^ "(logical *" ^ sv ^ ")"
			        else 
									 "EXTERN logical r_" ^ sv ^ "(" ^ (sty2str st) ^ "*" ^ sv ^ ")" 
									)) is)) ^ ";\n" ^
		(String.concat ";\n" (List.map (fun o -> 
			   (match o with (st,sv) -> 
					if sty2str st="integer" then 
						"EXTERN void w_" ^ sv ^ "(int " ^ sv ^ ")"
						else if sty2str st="boolean" || sty2str st="event" then
			      "EXTERN void w_" ^ sv ^ "(logical " ^ sv ^ ")"
						else 
						"EXTERN void w_" ^ sv ^ "(" ^ (sty2str st) ^ "" ^ sv ^ ")"
						)) os)) ^ ";\n"
			) pl

(*input, output, local declaration*)
(*without optimization,i.e.,reduce the local variables*)
let io_code_not_op pl= 
	List.map(
   function 
	 SProc(n,is,os,eqns,ws) -> 
		"/* => input signals */" ^ "\n" ^
		(String.concat ";\n" (List.map (fun i -> 
			   (match i with (st,sv) -> 
					       if sty2str st="integer" then
									  "static int " ^ sv
								 else if sty2str st="boolean" || sty2str st="event" then
			             "static logical " ^ sv
			           else 
									 sdecl2str i
									)) is)) ^ ";\n" ^
									"/* => output signals */" ^ "\n" ^
	  (String.concat ";\n" (List.map (fun o -> 
			   (match o with (st,sv) -> 
					if sty2str st="integer" then 
						"static int " ^ sv
						else if sty2str st="boolean" || sty2str st="event" then
			      "static logical " ^ sv
						else 
						sdecl2str o
						)) os)) ^ ";\n" ^
						"/* => local signals */" ^ "\n" ^
		(String.concat ";\n" (List.map (fun w ->
			    (match w with(st, sv) ->
						  if sty2str st="integer" then
									 "static int " ^ sv
								 else if sty2str st="boolean" || sty2str st="event" then
			             "static logical " ^ sv
			           else 
									 sdecl2str w
									)) ws)) ^ ";\n"
	 ) pl
	
(*with optimization*)
let get_vlist hashlist=
     Hashtbl.fold (
			   fun key value l -> key::l
				 ) hashlist []

let reduce_ws ws=
			List.fold_right (fun w l->
			  (match w with (st,sv) -> 
					let lvars=get_vlist Optimization.local_vars in
					(*print_string(String.concat "****" (List.map (fun x -> x) lvars) ^"\n");*)
					if List.mem sv lvars = false then
					begin
					if sty2str st="integer" then 
						("static int " ^ sv)::l
						else if sty2str st="boolean" || sty2str st="event" then
			     ("static logical " ^ sv)::l
					 	else 
						(sdecl2str w)::l
					end
					else
					l
					)) ws []	
								
let io_code_op pl = List.map(
   function 
	 SProc(n,is,os,eqns,ws) -> 
		"*/" ^ "\n" ^
		"/* => input signals */" ^ "\n" ^
		(String.concat ";\n" (List.map (fun i -> 
			   (match i with (st,sv) -> 
					       if sty2str st="integer" then
									  "static int " ^ sv
								 else if sty2str st="boolean" || sty2str st="event" then
			             "static logical " ^ sv
			           else 
									 sdecl2str i
									)) is)) ^ ";\n" ^
									"/* => output signals */" ^ "\n" ^
	  (String.concat ";\n" (List.map (fun o -> 
			   (match o with (st,sv) -> 
					if sty2str st="integer" then 
						"static int " ^ sv
						else if sty2str st="boolean" || sty2str st="event" then
			      "static logical " ^ sv
						else 
						sdecl2str o
						)) os)) ^ ";\n" ^
						"/* => local signals */" ^ "\n" ^
		(String.concat ";\n" (List.map (fun x -> x) (reduce_ws ws))) ^ ";\n"
	 ) pl

(*iteration part*)	

(*c1 and c2 => c1 && c2*)
(*read c1 => if (!r_c1(&c1)) return FALSE;*)
let c_action2code=function
	| Ass_c (s, se) -> begin match se with
                   | SIdent s1 -> s ^ "=" ^ s1    
                   | SCInt i -> s ^ "=" ^ (string_of_int i)
                   | SCReal r -> s ^ "=" ^ (string_of_float r)
                   | SCBool b -> s ^ "=" ^ (string_of_bool b)
	                 | SCString cs -> s ^ "=" ^ cs
	                 | SCChar c -> s ^ "=" ^ (Char.escaped c)
	                 | SFunc (f,[x]) -> if f="not" then
										               s ^ "=" ^ "!" ^ x
																	else
										              s ^ "=" ^ f ^" " ^ x 
	                 | SFunc (f,[x;y]) -> if f="and" then
										              s ^ "=" ^ x ^ " " ^ "&&" ^" " ^ y 
																	else if f="or" then
																		s ^ "=" ^ x ^ " " ^ "||" ^" " ^ y 
																	else
																		s ^ "=" ^ x ^ " " ^ f ^" " ^ y 
	                 | _ -> failwith "c_action2code"
									 end
	| Input_c s -> "if (!r_" ^ s ^ "(&" ^ s ^ ")) return FALSE;"
	
let rec tree_list_generation (codetreelist:CodeHierarchy.tree list) =
	 match codetreelist with
	| [] -> ""
	| ct::clt -> begin match ct with
	             | CodeHierarchy.Empty -> ""
							 | CodeHierarchy.Relation(cp,cl,cl') -> 
		             " if(" ^ cp ^ ")" ^ " \n{" ^ "\n" ^
								 String.concat ";\n " (List.map (fun x -> c_action2code x) !cl) 
			           ^ ";\n"
								 ^ tree_list_generation cl'
								 ^ " }" ^ "\n"
								 ^ tree_list_generation clt ^ "\n"
								end
								
let code_body (codetree:CodeHierarchy.tree)= match codetree with
	   | CodeHierarchy.Empty -> failwith("empty_tree")
	   | CodeHierarchy.Relation(p,l,l') -> "\n" ^
		  "/*" ^ "\n" ^
			"iteration part" ^ "\n" ^
			"*/" ^ "\n" ^
			"EXTERN logical step()" ^ "\n{" ^
			 String.concat ";\n " (List.map (fun x ->  c_action2code x) !l) 
			 ^ ";\n" 
			 ^ tree_list_generation l'
			 ^ "step_finalize();" ^ "\n" ^
       "return TRUE;" ^ "\n" 
			 ^ "}"


(*initial part*)

let get_initial eqns= List.fold_right(fun eqn initial->
	match eqn with
		  | SAss (s,e) -> initial
			| SAssSig (s,e) -> begin match e with
			                     | SDelay(sx,e1) -> [s ^ "=" ^ (sexp2str e1)]@initial
                           | SWhen(sx,w) -> initial
                           | SDefault(sx,d) -> initial
													end
	) eqns []
	
let initial_code pl= List.map(
   function 
	 SProc(n,is,os,eqns,ws) -> 
     "\n" ^
		"/* => initial part */" ^ "\n" ^
		"EXTERN logical initialize()"^ "\n{" ^
    String.concat ";\n " (List.map (fun ex ->ex) (get_initial eqns)) ^";\n " 
			^ "step_initialize();" ^ "\n " ^
      "return TRUE;" ^ "\n}" 
			^"\n" ^"\n" ^
			"static void step_initialize()" ^ "\n{" ^ "\n" ^
      "}"
			) pl


(*finalization part*)

let get_initial1 eqns= List.fold_right(fun eqn initial->
	match eqn with
		  | SAss (s,e) -> initial
			| SAssSig (s,e) -> begin match e with
			                     | SDelay(sx,e1) -> [s ^ "=" ^ sx]@initial
                           | SWhen(sx,w) -> initial
                           | SDefault(sx,d) -> initial
													end
	) eqns []
	
let finalization_code pl= List.map(
   function 
	 SProc(n,is,os,eqns,ws) -> 
     "\n" ^
		"/* => finalization part */" ^ "\n" ^
		"EXTERN logical step_finalize()" ^ "\n{" ^
    String.concat ";\n " (List.map (fun ex -> ex) (get_initial1 eqns)) ^ ";\n "
			^ "step_initialize();" ^ "\n " ^
      "return TRUE;" ^ "\n}" 
			) pl

