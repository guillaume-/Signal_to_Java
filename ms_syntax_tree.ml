(* Copyright 2013 Dumitru Potop Butucaru ( email: dumitru.potop_butucaru@inria.fr )

	 This program is free software: you can redistribute it and/or
	 modify it under the terms of the GNU General Public License as
	 published by the Free Software Foundation, either version 3 of the
	 License, or (at your option) any later version.

	 This program is distributed in the hope that it will be useful,
	 but WITHOUT ANY WARRANTY; without even the implied warranty of
	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 GNU General Public License for more details.

	 You should have received a copy of the GNU General Public License
	 along with this program.  If not, see <http://www.gnu.org/licenses/>
*)
open Ms_identifier
open Ms_fundamental_interfaces

module SyntaxTree = struct
(* The types allowing the construction of the simplified syntax tree
	of a Signal program.  The simplifications consist in having one list
	of input signals and one list of output signals (multiple lists are
	unified), removal of parenthesis, etc.
*)


(* We only deal with enumerated types. This allows
	a representation of all finite types, including
	event and boolean, as well as integer ranges
	(but not as integers).

	Restricting the syntax and analysis to set 
	manipulations may not be very optimal. For instance,
	if at some point we want to use Boolean operators or
	integer range manipulations, it may prove difficult.

	To allow the subtyping of event into booleans, as used 
	by the Signal compiler (quite heavily), we allow enum variant
	identifiers to belong to more than one enum. Their base type is
	set to the first type defining them. Thus, the definition of
	type "boolean" should be made before that of type "event", so that
	"true" is clearly identified as a boolean. This "type of a constant"
	feature is actually never used in the code (except in some commented
	out code of the parser), but consistency should be preserved for
	the future.
    
	If the types declaring a given constant are not in the relation
	described above (larger before smaller), the result of the 
	analysis is undefined.
*)
	type typed_variant_set = {
	 tv_type_name : Identifier.t;
	 variant_set : IdentifierSet.t;
	}

    type direction =
		Input
		| Output
		| Local

    type signal_declaration = {
		signal_name : Identifier.t ;
		signal_type : Identifier.t ;
		signal_direction : direction ;
	}

    type signal_expression =  
      EnumVariantAtom of Identifier.t
	| SignalAtom of Identifier.t
	| ClockPlus of signal_expression*signal_expression
	| ClockMinus of signal_expression*signal_expression
	| ClockTimes of signal_expression*signal_expression
	| Delay of signal_expression*signal_expression
	| EqualityAtom of signal_expression*signal_expression
	| InAtom of signal_expression*typed_variant_set
	| Default of signal_expression*signal_expression
	| When of signal_expression*signal_expression
	| WhenAtom of Identifier.t
	| FunctionCall of Identifier.t*(signal_expression list)
	| WhenNotAtom of Identifier.t
	| NotAtom of Identifier.t
	| AndExp of signal_expression*signal_expression
	| OrExp of signal_expression*signal_expression
	| IntegerConstant of int
	| Plus of signal_expression * signal_expression
	| Minus of signal_expression * signal_expression
	| Times of signal_expression * signal_expression

    type assignment = {
		assigned_signal_name : Identifier.t ;
		signal_expression : signal_expression ;
	}

(* VP: [Regarding the clock operations b^+c, b^-c and b^*c]
   Normally, these expressions should be assigned to another signal,
   i.e. a^=b^-c or a:=b^-c, in order to denote that the instants of 
   the left signal (a) are the instants of b that are not instants of c.
   However, this definition is not conformed to the definition of
   clock constraints (sconstraint below), since the latter takes two 
   arguments (left and right), without "assigning" the right part to
   some left part. In addition, the abstracted version of the process 
   that is generated by the Signal compiler uses these clock constraints 
   as assignment statements.
   This is why, I choose to handle these three clock expressions as 
   assignments (type signal expression).
 *)
    type sconstraint_kind =
		ClockEquality
		| ClockLeq 
		| ClockLess
		| ClockWhen
		| ClockWhenNot
		| ClockExclusive

    (* This is a simple form of the clock constraint statement.
       There are only 2 arguments, which are mere signals, 
       not signal expressions.
     *)
    type sconstraint = {
	 constraint_kind : sconstraint_kind ;
	 left_signal_name : Identifier.t ;
	 right_signal_name : Identifier.t ;
	}

    (* Name of the instantiated process, list of outputs, list of inputs. *)
    type instantiation = {
		instance_process_name : Identifier.t ;
		instance_output_signals : Identifier.t list ;
		instance_input_expressions : signal_expression list ;
	} 

    type process_body = {
		assignment_list : assignment list ;
		constraint_list : sconstraint list ;
		instantiation_list : instantiation list
	} 

	type signal_declarations = {
		input_signal_list : signal_declaration list ;
		output_signal_list : signal_declaration list ;
		local_signal_list : signal_declaration list ;
	} 
  
	(* Process name, list of input signals, list of output signals. *)
	type process_header = {
		process_name : Identifier.t ;
		signal_declarations : signal_declarations ;
		local_process_list : process list ;
	} 
	and process = {
		header : process_header ;
		body : process_body ;
	}

	(* The input list contains the types of the parameters
		(identifiers). These are single-output functions 
		(unlike in Signal).
	*)
	type procedure_declaration  = {
		procedure_name : Identifier.t ;
		procedure_input_list : Identifier.t list ;
		procedure_output : Identifier.t ;
	}

	type specification = {
		process_list : process list ;
		type_declaration_list : typed_variant_set list ;
		procedure_declaration_list : procedure_declaration list ;
	}

  end
;;
